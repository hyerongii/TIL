# tree
## 트리 2

### 이진 탐색 트리(Binary Search Tree)

- Data 들을 빠르게 검색할 수 있도록 **체계적으로 저장**을 해두고, 최대 **O(log n)의 빠른 속도로 값을 검색**할 수 있는 자료구조

- 빠르게 검색될 수 있도록, 특정 규칙을 갖는 이진트리 형태로 값을 저장해둔다.

#### 리스트 vs BST

- BST는 리스트 보다 더 빠른 삽입/ 삭제 / 탐색이 가능하다

- 리스트 성능
    - 삽입: O(n), 단 맨 끝 삽입은 O(1)
    - 삭제: O(n), 단 맨 끝 삭제는 O(1)    
    - 탐색: O(n)

- BST 성능
    - 삽입: 평균 O(logN)
    - 삭제: 평균 O(logN)
    - 탐색: 평균 O(logN)

> 파이썬 공식 library에는 Binary Search Tree 자료구조가 내장되어 있지 않아 직접 구현해서 사용해야함

#### BST 동작원리 - 삽입

- 순서대로 부모노드보다 작으면 왼쪽 크면 오른쪽에 넣는다

<시간복잡도> - O(logN)

- 삽입을 위해, root부터 바닥 노드까지 탐색을 하며 자기 위치를 찾는다.
- 이는 트리의 높이(h)만큼 탐색 시간이 걸린다.
    - 2^(h) = 노드 수 (N) => logN = h

> 이진 탐색 트리는 완전 탐색 트리가 아님!
> 만약 리스트랑 BST랑 차이가 없는 경우(한쪽으로 편향되어있을 때)는 시간복잡도 O(N)임

#### BST 탐색 방법

<시간복잡도> - O(logN) ~ O(N)

#### BST 동작 원리 - 순회

- BST에서 DFS 중위순회를 하게 되면 key 값이 작은 순서대로 탐색이 가능하다.
- 오름차순으로 정렬이 된다!

#### 성능

- 탐색, 삽입, 삭제 시간은 트리의 높이 만큼 시간이 걸린다.
    - O(h), h: BST의 깊이(height)

- 평균의 경우 
    - 이진트리가 균형적으로 생성되어있는 경우
    - O(logN)

- 최악의 경우
    - 한쪽으로 치우친 경사 이진트리의 경우
    - O(N)
    - 순차탐색과 시간복잡도가 같다.

#### 삭제

- BST 규칙 유지해야함 (부모노드보다 작으면 왼쪽 크면 오른쪽)

1. 리프노드(자식없는 노드) 삭제 => 그냥 삭제
2. 자식이 하나일 때 -> 자식을 부모로 연결 후 삭제
3. 자식이 둘이라면 -> 삭제하고자 하는 노드의 왼쪽 서브트리의 가장 큰 값 or 오른쪽 서브트리의 가장 작은 값 으로 대체

<시간복잡도> - O(logN) -> 탐색하고 삭제하기 때문

#### 정리

- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 갖는다.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)

- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.

